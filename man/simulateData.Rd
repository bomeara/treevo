% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulateData.R
\name{simulateData}
\alias{simulateData}
\alias{parallelSimulation}
\title{Simulate data for initial TreEvo analysis}
\usage{
simulateData(phy, startingPriorsValues, intrinsicPriorsValues,
  extrinsicPriorsValues, startingPriorsFns, intrinsicPriorsFns,
  extrinsicPriorsFns, freevector, timeStep, intrinsicFn, extrinsicFn,
  giveUpAttempts = 10, verbose = FALSE, checks = TRUE, niter.brown = 25,
  niter.lambda = 25, niter.delta = 25, niter.OU = 25, niter.white = 25)

parallelSimulation(phy, startingPriorsValues, intrinsicPriorsValues,
  extrinsicPriorsValues, startingPriorsFns, intrinsicPriorsFns,
  extrinsicPriorsFns, freevector, timeStep, intrinsicFn, extrinsicFn, nrepSim,
  coreLimit, multicore, checkpointFile = NULL, checkpointFreq = 24,
  verbose = FALSE, niter.brown = 25, niter.lambda = 25,
  niter.delta = 25, niter.OU = 25, niter.white = 25)
}
\arguments{
\item{phy}{A phylogenetic tree, in package \code{ape}'s \code{phylo} format.}

\item{startingPriorsValues}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{intrinsicPriorsValues}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{extrinsicPriorsValues}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{startingPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{intrinsicPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{extrinsicPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{freevector}{A logical vector (with length equal to the number of parameters), indicating free (\code{TRUE}) and
fixed (\code{FALSE}) parameters.}

\item{timeStep}{This value corresponds to the number of discrete time steps
on the shortest branch}

\item{intrinsicFn}{Name of intrinsic function that traits should be simulated
under.}

\item{extrinsicFn}{Name of extrinsic function that traits should be simulated
under.}

\item{giveUpAttempts}{Value for when to stop the analysis if \code{NA} values are present.}

\item{verbose}{If \code{TRUE}, gives messages about how the simulation is progessing via \code{print}.}

\item{checks}{If \code{TRUE}, checks inputs for consistency. This activity is skipped (\code{checks = FALSE})
when run in parallel by \code{parallelSimulation}, and instead is only checked once.}

\item{niter.brown}{Number of random starts for the Brownian Motion (BM) model (minimum of 2).}

\item{niter.lambda}{Number of random starts for the lambda model (minimum of 2).}

\item{niter.delta}{Number of random starts for the delta model (minimum of 2).}

\item{niter.OU}{Number of random starts for the Ornstein-Uhlenbeck (OU) model (minimum of 2).}

\item{niter.white}{Number of random starts for the white noise model (minimum of 2).}

\item{nrepSim}{Number of replicated simulations to run.}

\item{coreLimit}{Maximum number of cores to be used.}

\item{multicore}{Whether to use multicore, default is \code{FALSE}. If \code{TRUE}, one of
two suggested packages must be installed, either \code{doMC} (for UNIX systems) or
\code{doParallel} (for Windows), which are used to activate multithreading.
If neither package is installed, this function will fail if \code{multicore=TRUE}.}

\item{checkpointFile}{Optional file name for checkpointing simulations}

\item{checkpointFreq}{Saving frequency for checkpointing}
}
\value{
Returns matrix of \code{trueFreeValues} and summary statistics for
simulations.
}
\description{
The function \code{simulateData} pulls parameters from prior distributions and simulates
continuous characters, and is uSsed by TreEvo functions \code{doRun_prc} and \code{doRun_rej} to calculate simulations.
}
\details{
\code{parallelSimulation} is a wrapper function for \code{simulateData} that allows for multithreading
and checkpointing.
}
\examples{

data(simRun)


# example simulation

	
simData<-simulateData(phy=simPhy, 
	startingPriorsValues, 
	intrinsicPriorsValues, 
	extrinsicPriorsValues, 
	startingPriorsFns, 
	intrinsicPriorsFns, 
	extrinsicPriorsFns, 
	freevector, 	
	timeStep=0.0001,
	intrinsicFn=brownianIntrinsic,
	extrinsicFn=nullExtrinsic,
	giveUpAttempts=10, 
	verbose=TRUE,
	niter.brown=25, niter.lambda=25, niter.delta=25, niter.OU=25, niter.white=25) 

simDataParallel<-parallelSimulation(nrepSim=10, coreLimit=1, phy=simPhy, 
	startingPriorsValues, 
	intrinsicPriorsValues, 
	extrinsicPriorsValues, 
	startingPriorsFns, 
	intrinsicPriorsFns, 
	extrinsicPriorsFns, 
	freevector, 	 
multicore=FALSE, 
	checkpointFile=NULL, checkpointFreq=24, verbose=FALSE,
	timeStep=0.0001,
	intrinsicFn=brownianIntrinsic,
	extrinsicFn=nullExtrinsic,
	niter.brown=25, niter.lambda=25, niter.delta=25, niter.OU=25, niter.white=25) 

}
\author{
Brian O'Meara and Barb Banbury
}
