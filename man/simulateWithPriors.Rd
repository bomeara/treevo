% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulateWithPriors.R
\name{simulateWithPriors}
\alias{simulateWithPriors}
\alias{parallelSimulateWithPriors}
\title{Simulate data for initial TreEvo analysis}
\usage{
simulateWithPriors(phy = NULL, intrinsicFn, extrinsicFn, startingPriorsFns,
  startingPriorsValues, intrinsicPriorsFns, intrinsicPriorsValues,
  extrinsicPriorsFns, extrinsicPriorsValues, timeStep, giveUpAttempts = 10,
  verbose = FALSE, checks = TRUE, taxon.df = NULL, freevector = NULL,
  niter.brown = 25, niter.lambda = 25, niter.delta = 25, niter.OU = 25,
  niter.white = 25)

parallelSimulateWithPriors(nrepSim, multicore, coreLimit, phy, intrinsicFn,
  extrinsicFn, startingPriorsFns, startingPriorsValues, intrinsicPriorsFns,
  intrinsicPriorsValues, extrinsicPriorsFns, extrinsicPriorsValues, timeStep,
  checkpointFile = NULL, checkpointFreq = 24, verbose = FALSE,
  freevector = NULL, taxon.df = NULL, giveUpAttempts = 10,
  niter.brown = 25, niter.lambda = 25, niter.delta = 25, niter.OU = 25,
  niter.white = 25)
}
\arguments{
\item{phy}{A phylogenetic tree, in package \code{ape}'s \code{phylo} format.}

\item{intrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, regardless of the trait values of other taxa.}

\item{extrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, based on their own ('internal') trait vlaue and the trait values
of other taxa.}

\item{startingPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{startingPriorsValues}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{intrinsicPriorsFns}{Vector containing names of prior distributions to
use for intrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{intrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the intrinsic function and nrow=2 (two parameters to pass to prior distribution)}

\item{extrinsicPriorsFns}{Vector containing names of prior distributions to
use for extrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{extrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the extrinsic function and nrow=2 (two parameters to pass to prior distribution)}

\item{timeStep}{This value corresponds to the number of discrete time steps
on the shortest branch.}

\item{giveUpAttempts}{Value for when to stop the analysis if \code{NA} values are present.}

\item{verbose}{If \code{TRUE}, gives messages about how the simulation is progessing via \code{print}.}

\item{checks}{If \code{TRUE}, checks inputs for consistency. This activity is skipped (\code{checks = FALSE})
when run in parallel by \code{parallelSimulateWithPriors}, and instead is only checked once. This
argument also controls whether \code{simulateWithPriors} assigns \code{freevector} as an attribute to the
output produced.}

\item{taxon.df}{A data.frame containing data on nodes (both tips and internal nodes) output by various internal functions.
Can be supplied as input to spead up repeated calculations, but by default is
\code{NULL}, which instead forces a calculation from input \code{phy}.}

\item{freevector}{A logical vector (with length equal to the number of parameters), indicating free (\code{TRUE}) and
fixed (\code{FALSE}) parameters.}

\item{niter.brown}{Number of random starts for the Brownian Motion (BM) model (minimum of 2).}

\item{niter.lambda}{Number of random starts for the lambda model (minimum of 2).}

\item{niter.delta}{Number of random starts for the delta model (minimum of 2).}

\item{niter.OU}{Number of random starts for the Ornstein-Uhlenbeck (OU) model (minimum of 2).}

\item{niter.white}{Number of random starts for the white noise model (minimum of 2).}

\item{nrepSim}{Number of replicated simulations to run.}

\item{multicore}{Whether to use multicore, default is \code{FALSE}. If \code{TRUE}, one of
two suggested packages must be installed, either \code{doMC} (for UNIX systems) or
\code{doParallel} (for Windows), which are used to activate multithreading.
If neither package is installed, this function will fail if \code{multicore=TRUE}.}

\item{coreLimit}{Maximum number of cores to be used.}

\item{checkpointFile}{Optional file name for checkpointing simulations}

\item{checkpointFreq}{Saving frequency for checkpointing}
}
\value{
Function \code{simulateWithPriors} returns a vector of \code{trueFreeValues},
the true generating parameters used in the simulation
(a set of values as long as the number of freely varying parameters), concatenated with a set of summary statistics for
the simulation. Function \code{parallelSimulateWithPriors} returns a matrix of such vectors bound
together, with each row representing a different simulation. By default,
both functions also assign a logical vector named \code{freevector}, indicating the total number of 
parameters and which parameters are freely-varying (have \code{TRUE} values), as an attribute of
the output.
}
\description{
The \code{simulateWithPriors} function pulls parameters from prior distributions and conducts a single simulation of
continuous trait evolution (using \code{\link{doSimulation}} functions), returning useful summary statistics for ABC.
\code{parallelSimulateWithPriors} is a wrapper function for \code{simulateWithPriors} that allows for multithreading
and checkpointing. This family of functions is mostly used as internal components, generating simulations
within ABC analyses using the \code{\link{doRun}} functions. See \emph{Note} below.
}
\note{
The \code{\link{simulateWithPriors}} functions are effectively the engine that powers the \code{\link{doRun}}
functions, while the \code{\link{doSimulation}} functions are the pistons within the \code{\link{simulateWithPriors}} engine.
In general, most users will just drive the car - they will just use \code{\link{doRun}}, but some users may
want to use \code{\link{simulateWithPriors}} or \code{\link{doSimulation}} functions to do various simulations.
}
\examples{

simPhy<-rcoal(30)

# example simulation
	
simData<-simulateWithPriors(phy=simPhy, 
  intrinsicFn=brownianIntrinsic,
  extrinsicFn=nullExtrinsic,
  startingPriorsFns="normal",
  startingPriorsValues=matrix(c(mean(simChar[,1]), sd(simChar[,1]))),
  intrinsicPriorsFns=c("exponential"),
  intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE),
  extrinsicPriorsFns=c("fixed"),
  extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE),
  timeStep=10^-6,
	 freevector=NULL, 	
	 giveUpAttempts=10, 
	 verbose=TRUE,
	 niter.brown=25, niter.lambda=25, niter.delta=25, niter.OU=25, niter.white=25) 

simData

simDataParallel<-parallelSimulateWithPriors( 
  nrepSim=10, multicore=FALSE, coreLimit=1, 
  phy=simPhy,
  intrinsicFn=brownianIntrinsic,
  extrinsicFn=nullExtrinsic,
  startingPriorsFns="normal",
  startingPriorsValues=matrix(c(mean(simChar[,1]), sd(simChar[,1]))),
  intrinsicPriorsFns=c("exponential"),
  intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE),
  extrinsicPriorsFns=c("fixed"),
  extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE), 
  timeStep=10^-6,
  checkpointFile=NULL, checkpointFreq=24,
  verbose=FALSE,
  freevector=NULL, taxon.df=NULL,
  niter.brown=25, niter.lambda=25, niter.delta=25, niter.OU=25, niter.white=25) 

simDataParallel

}
\author{
Brian O'Meara and Barb Banbury
}
