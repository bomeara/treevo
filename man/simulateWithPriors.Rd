% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulateWithPriors.R
\name{simulateWithPriors}
\alias{simulateWithPriors}
\alias{parallelSimulateWithPriors}
\title{Simulate data for initial TreEvo analysis}
\usage{
simulateWithPriors(phy = NULL, intrinsicFn, extrinsicFn, startingPriorsFns,
  startingPriorsValues, intrinsicPriorsFns, intrinsicPriorsValues,
  extrinsicPriorsFns, extrinsicPriorsValues, generation.time = 1000,
  TreeYears = max(branching.times(phy)) * 1e+06, timeStep = NULL,
  giveUpAttempts = 10, verbose = FALSE, checks = TRUE, taxonDF = NULL,
  freevector = NULL)

parallelSimulateWithPriors(nrepSim, multicore, coreLimit, phy, intrinsicFn,
  extrinsicFn, startingPriorsFns, startingPriorsValues, intrinsicPriorsFns,
  intrinsicPriorsValues, extrinsicPriorsFns, extrinsicPriorsValues,
  generation.time = 1000, TreeYears = max(branching.times(phy)) * 1e+06,
  timeStep = NULL, checkpointFile = NULL, checkpointFreq = 24,
  verbose = TRUE, verboseNested = FALSE, freevector = NULL,
  taxonDF = NULL, giveUpAttempts = 10)
}
\arguments{
\item{phy}{A phylogenetic tree, in package \code{ape}'s \code{phylo} format.}

\item{intrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, regardless of the trait values of other taxa.}

\item{extrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, based on their own ('internal') trait vlaue and the trait values
of other taxa.}

\item{startingPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{startingPriorsValues}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{intrinsicPriorsFns}{Vector containing names of prior distributions to
use for intrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{intrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the intrinsic function and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{extrinsicPriorsFns}{Vector containing names of prior distributions to
use for extrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{extrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the extrinsic function and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{generation.time}{The number of years per generation. This sets the coarseness of the simulation; if it's set to 1000,
for example, the population's trait values change every 1000 calender years. Note that this is in calender years (see description
for argument \code{TreeYears}), and not in millions of years (as is typical for dated trees in macroevolutionary studies).
Thus, if a branch is 1 million-year time-unit long, and a user applies the default \code{generation.time = 1000},
then 1000 evolutionary changes will be simulated along that branch.
See documentation for \code{\link{doSimulation}} for further details.}

\item{TreeYears}{The amount of calender time from the root to the furthest tip. Most trees in macroevolutionary studies are dated with
branch lengths in units of millions of years, and thus the default for this argument is \code{max(branching.times(phy)) * 1e6}.
If your tree has the most recent tip at time zero (i.e., the modern day), this would be the same as the root age of the tree. If your
branch lengths are not in millions of years, you should alter this argument. Otherwise, leave this argument alone.
See documentation for \code{\link{doSimulation}} for further details.}

\item{timeStep}{This value corresponds to the lenght of intervals between discrete evolutionary events ('generations')
simulated along branches, relative to a rescaled tree where the root to furthest tip distance is 1. For example,
\code{timeStep = 0.01} of would mean 100 (i.e., 1 / 0.01) evolutionary changes would be expected to occur from
the root to the furthest tip. (Note that the real number simulated will be much less, because simulations start
over at each branching node.) Ideally, \code{timeStep} (or its effective value, via other arguments) should be
as short as is computationally possible.
Typically \code{NULL} by default and
determined internally as follows: \code{timeStep = generation.time / TreeYears}.
Can be provided a value as an alternative to using arguments \code{generation.time}
and \code{TreeYears}, which would then be overridden.
See documentation for \code{\link{doSimulation}} for further details.}

\item{giveUpAttempts}{Value for when to stop the analysis if \code{NA} values are present.}

\item{verbose}{If \code{TRUE}, gives messages about how the simulation is progessing via \code{message}.}

\item{checks}{If \code{TRUE}, checks inputs for consistency. This activity is skipped (\code{checks = FALSE})
when run in parallel by \code{parallelSimulateWithPriors}, and instead is only checked once. This
argument also controls whether \code{simulateWithPriors} assigns \code{freevector} as an attribute to the
output produced.}

\item{taxonDF}{A data.frame containing data on nodes (both tips and internal nodes) output by various internal functions.
Can be supplied as input to spead up repeated calculations, but by default is
\code{NULL}, which instead forces a calculation from input \code{phy}.}

\item{freevector}{A logical vector (with length equal to the number of parameters), indicating free (\code{TRUE}) and
fixed (\code{FALSE}) parameters.}

\item{nrepSim}{Number of replicated simulations to run.}

\item{multicore}{Whether to use multicore, default is \code{FALSE}. If \code{TRUE}, one of
two suggested packages must be installed, either \code{doMC} (for UNIX systems) or
\code{doParallel} (for Windows), which are used to activate multithreading.
If neither package is installed, this function will fail if \code{multicore=TRUE}.}

\item{coreLimit}{Maximum number of cores to be used.}

\item{checkpointFile}{Optional file name for checkpointing simulations}

\item{checkpointFreq}{Saving frequency for checkpointing}

\item{verboseNested}{Should looped runs of \code{simulateWithPriors} be verbose?}
}
\value{
Function \code{simulateWithPriors} returns a vector of \code{trueFreeValues},
the true generating parameters used in the simulation
(a set of values as long as the number of freely varying parameters), concatenated with a set of summary statistics for
the simulation. Function \code{parallelSimulateWithPriors} returns a matrix of such vectors bound
together, with each row representing a different simulation. By default,
both functions also assign a logical vector named \code{freevector}, indicating the total number of
parameters and which parameters are freely-varying (have \code{TRUE} values), as an attribute of
the output.
}
\description{
The \code{simulateWithPriors} function pulls parameters from prior distributions and conducts a single simulation of
continuous trait evolution (using the \code{\link{doSimulation}} function), returning useful summary statistics for ABC.
\code{parallelSimulateWithPriors} is a wrapper function for \code{simulateWithPriors} that allows for multithreading
and checkpointing. This family of functions is mostly used as internal components, generating simulations
within ABC analyses using the \code{\link{doRun}} functions. See \emph{Note} below.
}
\note{
The \code{\link{simulateWithPriors}} functions are effectively the engine that powers the  \code{\link{doRun}}
functions, while the \code{\link{doSimulation}} function is the pistons within the \code{\link{simulateWithPriors}} engine.
In general, most users will just drive the car - they will just use \code{\link{doRun}}, but some users may
want to use \code{\link{simulateWithPriors}} or \code{\link{doSimulation}} to do various simulations.
}
\examples{
\donttest{
set.seed(1)
tree<-rcoal(20)
# get realistic edge lengths
tree$edge.length<-tree$edge.length*20

# example simulation

# NOTE: the example analyses involve too few simulations, with coarse time-units
	# - all for the sake of examples that reasonably test the functions
	
simData<-simulateWithPriors(phy=tree,
  intrinsicFn=brownianIntrinsic,
  extrinsicFn=nullExtrinsic,
  startingPriorsFns="normal",
  startingPriorsValues=matrix(c(mean(simChar[,1]), sd(simChar[,1]))),
  intrinsicPriorsFns=c("exponential"),
  intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE),
  extrinsicPriorsFns=c("fixed"),
  extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE),
  generation.time=100000,
	 freevector=NULL, 	
	 giveUpAttempts=10,
	 verbose=TRUE)

simData

simDataParallel<-parallelSimulateWithPriors(
  nrepSim=2, multicore=FALSE, coreLimit=1,
  phy=tree,
  intrinsicFn=brownianIntrinsic,
  extrinsicFn=nullExtrinsic,
  startingPriorsFns="normal",
  startingPriorsValues=matrix(c(mean(simChar[,1]), sd(simChar[,1]))),
  intrinsicPriorsFns=c("exponential"),
  intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE),
  extrinsicPriorsFns=c("fixed"),
  extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE),
  generation.time=100000,
  checkpointFile=NULL, checkpointFreq=24,
  verbose=TRUE, freevector=NULL, taxonDF=NULL)

simDataParallel

}

}
\author{
Brian O'Meara and Barb Banbury
}
