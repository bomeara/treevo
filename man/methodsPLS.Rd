% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methodsPLS.R
\name{methodsPLS}
\alias{methodsPLS}
\alias{returnPLSModel}
\alias{PLSTransform}
\title{Fitting Univariate Partial Least Squares Models to Free Parameters in ABC}
\usage{
returnPLSModel(trueFreeValuesMatrix, summaryValuesMatrix,
  validation = "CV", scale = TRUE, variance.cutoff = 95,
  verbose = TRUE, segments = min(10, nrow(summaryValuesMatrix) - 1),
  ...)

PLSTransform(summaryValuesMatrix, pls.model)
}
\arguments{
\item{trueFreeValuesMatrix}{Matrix of true free values from simulations.}

\item{summaryValuesMatrix}{Matrix of summary statistics from simulations.}

\item{validation}{Character argument controlling what
validation procedure is used by \code{\link{plsr}}.
Default is \code{"CV"} for cross-validation.}

\item{scale}{This argument is passed to \code{\link{plsr}}.
It may be a numeric vector, or logical. If numeric vector, 
the input is scaled by dividing each variable with the corresponding element of scale.
If \code{scale = TRUE}, the inpus is scaled by dividing
each variable by its sample standard deviation.
If cross-validation is selected (the default for \code{returnPLSModel}), 
scaling by the standard deviation is done for every segment.}

\item{variance.cutoff}{Minimum threshold percentage of variance explained for the
number of components included in the final PLS model fit. This value is a
percentage and must be between 0 and 100. Default is 95 percent.}

\item{verbose}{If \code{TRUE}, helpful warning messages
will be made when you make questionable decisions.}

\item{segments}{Number of segments of data used for crossvalidaton
by \code{pls::cvsegments}. The number of segments cannot exceed the
number of simulations. The default number of segments as set for normal
use of \code{plsr} is 10, which leads to issues when a trial analysis
uses fewer than 10 simulations. Instead, we will pass an alternative
value for the number of segments - either 10, or the number of rows
in \code{summaryValuesMatrix}. Thus, this is a default value of 
\code{min(10,} \code{nrow(summaryValuesMatrix))}, or can be changed
by the user. A hard minimum of 3 is required.}

\item{...}{Additional arguments, passed to \code{\link{plsr}}.}

\item{pls.model}{Output from \code{\link{returnPLSModel}}.}
}
\value{
Function \code{returnPLSModel} returns a PLS model, and
function \code{PLSTransform} returns transformed summary statistics.
}
\description{
Function \code{returnPLSModel} fits a PLS regression (using
\code{\link{plsr}}) individually to each freely varying parameter of a model, unlike
a true multivariate PLS regression. A secondary step than limits the number
of components to those that explain some minimum cumulative percentage
of variance (see argument \code{variance.cutoff}).  For ABC, this seems to result in much
better results, without one parameter dominating the combined variance.
}
\details{
Function \code{PLSTransform} uses results from a Partial Least Squares (PLS)
model fit with \code{returnPLSModel} to transform summary values.
}
\examples{
\donttest{
set.seed(1)
simPhyExample <- rcoal(20)
simPhyExample$edge.length <- simPhyExample$edge.length * 20

# example simulation

nSimulations <- 6

simDataParallel <- parallelSimulateWithPriors(
   nrepSim = nSimulations, 
   multicore = FALSE, 
   coreLimit = 1, 
   phy = simPhyExample, 
   intrinsicFn = brownianIntrinsic, 
   extrinsicFn = nullExtrinsic, 
   startingPriorsFns = "normal", 
   startingPriorsValues = list(
       c(mean(simCharExample[, 1]), 
       sd(simCharExample[, 1]))), 
   intrinsicPriorsFns = c("exponential"), 
   intrinsicPriorsValues = list(10), 
   extrinsicPriorsFns = c("fixed"), 
   extrinsicPriorsValues = list(0), 
   generation.time = 10000, 
   checkpointFile = NULL, 
   checkpointFreq = 24, 
   verbose = FALSE, 
   freevector = NULL, 
   taxonDF = NULL
   )

nParFree <- sum(attr(simDataParallel, "freevector"))

# separate the simulation results: 
   # 'true' generating parameter values from the summary values
trueFreeValuesMat <- simDataParallel[, 1:nParFree]
summaryValuesMat <- simDataParallel[, -1:-nParFree]

PLSmodel <- returnPLSModel(
    trueFreeValuesMatrix = trueFreeValuesMat, 
    summaryValuesMatrix = summaryValuesMat, 
    validation = "CV", 
    scale = TRUE, 
    variance.cutoff = 95 , 
    segments = nSimulations
    )

PLSmodel

PLSTransform(
    summaryValuesMatrix = summaryValuesMat, 
    pls.model = PLSmodel
    )
}

}
\seealso{
Function \code{returnPLSModel} effectively wraps function \code{plsr}
from package \code{pls} (see documentation at \code{\link[pls]{mvr}}).
}
\author{
Brian O'Meara and Barb Banbury
}
