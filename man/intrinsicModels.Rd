% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CredInt.R, R/GetBMRatePrior.R,
%   R/HPD.R, R/PLSRejection.R, R/PLSTransform.R, R/PairwiseESS.R,
%   R/PairwiseKS.R, R/abcmodels.intrinsic.R, R/doSimulation.R,
%   R/doSimulationWithPossibleExtinction.R, R/getSimulationSplits.R,
%   R/getTaxonDFWithPossibleExtinction.R, R/interparticleDistance.R,
%   R/mutateState.R, R/pairings.R, R/parallelSimulation.R,
%   R/parentOffspringPlots.R, R/plotPosteriors.R, R/plotPrior.R,
%   R/plotUnivariatePosteriorVsPrior.R, R/pullFromPrior.R,
%   R/registerMulticoreEnv.R, R/summarizeTaxonStates.R
\name{intrinsicModels}
\alias{intrinsicModels}
\alias{CredInt}
\alias{intrinsicModels}
\alias{GetBMRatePrior}
\alias{intrinsicModels}
\alias{HPD}
\alias{intrinsicModels}
\alias{PLSRejection}
\alias{intrinsicModels}
\alias{PLSTransform}
\alias{intrinsicModels}
\alias{PairwiseESS}
\alias{intrinsicModels}
\alias{PairwiseKS}
\alias{intrinsicModels}
\alias{nullIntrinsic}
\alias{brownianIntrinsic}
\alias{boundaryIntrinsic}
\alias{boundaryMinIntrinsic}
\alias{autoregressiveIntrinsic}
\alias{minBoundaryAutoregressiveIntrinsic}
\alias{autoregressiveIntrinsicTimeSlices}
\alias{autoregressiveIntrinsicTimeSlicesConstantMean}
\alias{autoregressiveIntrinsicTimeSlicesConstantSigma}
\alias{intrinsicModels}
\alias{doSimulation}
\alias{intrinsicModels}
\alias{doSimulationWithPossibleExtinction}
\alias{intrinsicModels}
\alias{getSimulationSplits}
\alias{intrinsicModels}
\alias{getTaxonDFWithPossibleExtinction}
\alias{intrinsicModels}
\alias{interparticleDistance}
\alias{intrinsicModels}
\alias{mutateState}
\alias{intrinsicModels}
\alias{pairings}
\alias{intrinsicModels}
\alias{parallelSimulation}
\alias{intrinsicModels}
\alias{parentOffspringPlots}
\alias{intrinsicModels}
\alias{plotPosteriors}
\alias{intrinsicModels}
\alias{plotPrior}
\alias{intrinsicModels}
\alias{getUnivariatePriorCurve}
\alias{intrinsicModels}
\alias{getUnivariatePosteriorCurve}
\alias{intrinsicModels}
\alias{pullFromPrior}
\alias{intrinsicModels}
\alias{registerMulticoreEnv}
\alias{intrinsicModels}
\alias{summarizeTaxonStates}
\title{Bayesian Credible Interval}
\usage{
CredInt(particleDataFrame, percent = 0.95)

GetBMRatePrior(phy, traits, timeStep)

HPD(particleDataFrame, percent = 0.95, returnData = F)

PLSRejection(summaryValuesMatrix, trueFreeValuesMatrix, phy, traits,
  abcTolerance, verbose = TRUE, validation = "CV", scale = TRUE,
  variance.cutoff = 95)

PLSTransform(summaryValuesMatrix, pls.model)

PairwiseESS(particleDataFrame)

PairwiseKS(particleDataFrame)

nullIntrinsic(params, states, timefrompresent)

brownianIntrinsic(params, states, timefrompresent)

boundaryIntrinsic(params, states, timefrompresent)

boundaryMinIntrinsic(params, states, timefrompresent)

autoregressiveIntrinsic(params, states, timefrompresent)

minBoundaryAutoregressiveIntrinsic(params, states, timefrompresent)

autoregressiveIntrinsicTimeSlices(params, states, timefrompresent)

autoregressiveIntrinsicTimeSlicesConstantMean(params, states, timefrompresent)

autoregressiveIntrinsicTimeSlicesConstantSigma(params, states, timefrompresent)

doSimulation(splits, intrinsicFn, extrinsicFn, startingValues, intrinsicValues,
  extrinsicValues, timeStep, saveHistory = FALSE, saveRealParams = FALSE,
  jobName = "")

doSimulationWithPossibleExtinction(taxon.df, intrinsicFn, extrinsicFn,
  startingValues, intrinsicValues, extrinsicValues, timeStep,
  saveHistory = FALSE, saveRealParams = FALSE, jobName = "",
  returnAll = FALSE, verbose = FALSE, reject.NaN = TRUE)

getSimulationSplits(phy)

getTaxonDFWithPossibleExtinction(phy)

interparticleDistance(x, y, abs = TRUE)

mutateState(startingState, standardDevFactor, priorValues, priorFn)

pairings(nRuns)

parallelSimulation(nrepSim, coreLimit, taxon.df, phy, startingPriorsValues,
  intrinsicPriorsValues, extrinsicPriorsValues, startingPriorsFns,
  intrinsicPriorsFns, extrinsicPriorsFns, freevector, timeStep, intrinsicFn,
  extrinsicFn, multicore, checkpointFile = NULL, checkpointFreq = 24,
  niter.brown = 25, niter.lambda = 25, niter.delta = 25, niter.OU = 25,
  niter.white = 25)

parentOffspringPlots(particleDataFrame)

plotPosteriors(particleDataFrame, PriorMatrix, realParam = FALSE,
  realParamValues = NA)

plotPrior(priorFn = match.arg(arg = priorFn, choices = c("fixed", "uniform",
  "normal", "lognormal", "gamma", "exponential"), several.ok = FALSE),
  priorVariables, plotQuants = TRUE, plotLegend = TRUE)

getUnivariatePriorCurve(priorValues, priorFn, nPoints = 1e+05, from = NULL,
  to = NULL, prob = 0.95)

getUnivariatePosteriorCurve(acceptedValues, from = NULL, to = NULL,
  prob = 0.95)

pullFromPrior(priorValues, priorFn)

registerMulticoreEnv(nCore)

summarizeTaxonStates(taxa)
}
\arguments{
\item{particleDataFrame}{particleDataFrame output from doRun}

\item{percent}{Probability content of HPD}

\item{phy}{Tree (Phylogenetic tree in phylo format)}

\item{traits}{data matrix with rownames equal to phy}

\item{timeStep}{time in a single iteration of the discrete-time simulation}

\item{returnData}{Option to return data that falls within HPD interval}

\item{summaryValuesMatrix}{Matrix of summary statistics from simulations}

\item{trueFreeValuesMatrix}{Matrix of true free values from simulations}

\item{abcTolerance}{Proportion of accepted simulations}

\item{verbose}{option to print progress to screen}

\item{validation}{Cross Validation procedure for abc}

\item{scale}{scale for pls.model.list}

\item{variance.cutoff}{variance cutoff for pls.model.list}

\item{pls.model}{results from returnPLSModel}

\item{params}{describes input paramaters for the model (see Description)}

\item{states}{vector of states for each taxon}

\item{timefrompresent}{which time slice in the tree}

\item{splits}{Output from the function getSimulationSplits; is a data frame
of branching times, ancestor and descendant vectors}

\item{intrinsicFn}{Name of intrinsic function characters should be simulated
under}

\item{extrinsicFn}{Name of extrinsic function characters should be simulated
under}

\item{startingValues}{State at the root}

\item{intrinsicValues}{Vector of values corresponding to the params of the
intrinsic model}

\item{extrinsicValues}{Vector of values corresponding to the params of the
extrinsic model}

\item{saveHistory}{Saves the character history throughout the simulation}

\item{saveRealParams}{Saves intrinsicValues and extrinsicValues as both a
matrix and a vector}

\item{jobName}{Optional name for the job}

\item{taxon.df}{Output from the function getTaxonDFWithPossibleExtinction; is a data frame
with info on all the taxa (including internal ones)}

\item{returnAll}{If true, returns the values at each node}

\item{reject.NaN}{Stop run if any simulated value is NaN}

\item{startingState}{Character state prior to mutating}

\item{standardDevFactor}{Standard deviation}

\item{priorValues}{Vector of priorValues}

\item{priorFn}{Prior shape}

\item{nrepSim}{Number of simulations}

\item{coreLimit}{Number of cores to be used}

\item{startingPriorsValues}{Matrix with ncol=number of states (characters)
at root and nrow=2 (two parameters to pass to prior distribution)}

\item{intrinsicPriorsValues}{Matrix with ncol=number of states (characters)
at root and nrow=2 (two parameters to pass to prior distribution)}

\item{extrinsicPriorsValues}{Matrix with ncol=number of states (characters)
at root and nrow=2 (two parameters to pass to prior distribution)}

\item{startingPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of fixed, uniform, normal, lognormal, gamma,
exponential}

\item{intrinsicPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of fixed, uniform, normal, lognormal, gamma,
exponential}

\item{extrinsicPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of fixed, uniform, normal, lognormal, gamma,
exponential}

\item{freevector}{A vector (length=number of parameters) of free (T) and
fixed (F) parameters}

\item{multicore}{Whether to use multicore, default is FALSE. If TRUE, one of
two suggested packages must be installed, either 'doMC' (for UNIX systems) or
'doParallel' (for Windows), which are used to activate multithreading.
If neither package is installed, this function will fail if multicore=TRUE.}

\item{checkpointFile}{Optional file name for checkpointing simulations}

\item{checkpointFreq}{Saving frequency for checkpointing}

\item{niter.brown}{Number of random starts for BM model (min of 2)}

\item{niter.lambda}{Number of random starts for lambda model (min of 2)}

\item{niter.delta}{Number of random starts for delta model (min of 2)}

\item{niter.OU}{Number of random starts for OU model (min of 2)}

\item{niter.white}{Number of random starts for white model (min of 2)}

\item{PriorMatrix}{PriorMatrix from TreEvo results, can be a single matrix
or a list of matrices}

\item{realParam}{Plot line segments where real parameter values are known}

\item{realParamValues}{Values for real paramters, include a value for each
parameter (inlcuding fixed values)}

\item{priorVariables}{Variables needed to describe the shape of the
distribution.  uniform distributions=c(min, max); normal
distributions=c(mean, sd); lognormal distributions=c(mean, sd); gamma
distributions=c(shape, scale); exponential distributions=c(rate)}

\item{plotQuants}{If TRUE, plots line segments at the quantiles}

\item{plotLegend}{If TRUE, plots legend box with quantile values}

\item{nPoints}{Number of points}

\item{from}{Lower bound, if any}

\item{to}{Upper bound, if any}

\item{prob}{Probability content of HPD}

\item{acceptedValues}{Vector of accepted particle values}

\item{particleDataFrame}{particleDataFrame output from doRun}

\item{percent}{Probability content of HPD}

\item{phy}{Tree (Phylogenetic tree in phylo format)}

\item{traits}{data matrix with rownames equal to phy}

\item{summaryValuesMatrix}{Matrix of summary statistics from simulations}

\item{particleDataFrame}{particleDataFrame can be a single data frame or a
list of data frames}

\item{particleDataFrame}{List of particleDataFrames from separate runs}

\item{timeStep}{This value corresponds to the number of discrete time steps
on the shortest branch}

\item{intrinsicFn}{Name of intrinsic function characters should be simulated
under}

\item{extrinsicFn}{Name of extrinsic function characters should be simulated
under}

\item{startingValues}{State at the root}

\item{intrinsicValues}{Vector of values corresponding to the params of the
intrinsic model}

\item{extrinsicValues}{Vector of values corresponding to the params of the
extrinsic model}

\item{timeStep}{This value corresponds to the number of discrete time steps
on the shortest branch}

\item{saveHistory}{Saves the character history throughout the simulation}

\item{saveRealParams}{Saves intrinsicValues and extrinsicValues as both a
matrix and a vector}

\item{jobName}{Optional name for the job}

\item{verbose}{If TRUE, chat about how the sim is going}

\item{phy}{Tree (ape phylo format)}

\item{phy}{Tree (ape phylo format)}

\item{taxon.df}{object from getTaxonDFWithPossibleExtinction}

\item{phy}{Tree (Phylogenetic tree in phylo format)}

\item{timeStep}{This value corresponds to the number of discrete time steps}

\item{intrinsicFn}{Name of intrinsic function characters should be simulated
under (as used by doSimulation)}

\item{extrinsicFn}{Name of extrinsic function characters should be simulated
under (as used by doSimulation)}

\item{particleDataFrame}{particleDataFrame from TreEvo results}

\item{particleDataFrame}{particleDataFrame from TreEvo results, can be a
single data frame or a list of data frames}

\item{priorFn}{Prior shape; either "fixed", "uniform", "normal",
"lognormal", "gamma", "exponential"}

\item{priorValues}{Variables needed to describe the shape of the
distribution.  uniform distributions=c(min, max); normal
distributions=c(mean, sd); lognormal distributions=c(mean, sd); gamma
distributions=c(shape, scale); exponential distributions=c(rate)}

\item{priorFn}{Prior shape; either "fixed", "uniform", "normal",
"lognormal", "gamma", "exponential"}

\item{from}{Lower bound, if any}

\item{to}{Upper bound, if any}

\item{prob}{Probability content of HPD}
}
\value{
Returns a matrix with weighted mean, sd, upper and lower credible
intervals for each free parameter

Returns a matrix of prior values

Returns a matrix with weighted mean, sd, upper and lower HPD for
each free parameter

Returns a list of the particle data frame and abc distances.

Returns transformed summary statistics

Returns a matrix with ESS values of all pairwise runs

Returns a matrix with Kolmogorov-Smirnov values of all pairwise runs

A matrix of values representing character displacement from a single
time step in the tree.

A data frame of species character (tip) values in the tree.

A data frame of species character (tip) values in the tree (unless returnAll==TRUE, in which case it returns the raw df from the sim).

A data frame of branching times, ancestor and descendant vectors

A list of abctaxon objects

Returns matrix of trueFreeValues and summary statistics for
simulations

Returns a layout of parent-offspring plots

Returns a plot for each free parameter.

Returns a distribution plot

Returns a list of x and y density coordinates, mean, and lower and
upper HPD

Returns a list of x and y density coordinates, mean, and lower and
upper HPD
}
\description{
This function calculates credible interval for each free parameter

This function automatically calculates prior distributions for BM model of
evolution

This function calculates HPD for each free parameter

This function automatically calculates prior distributions for the Brownian Motion model of
evolution.

Uses results from the PLS model to transform summary values

This function calculates ESS on results.  Performs the best when results are
from multiple runs.

This function calculates Kolmogorov-Smirnov on results.

Functions describing various models of 'intrinsic' evolution (i.e. evolutionary processes intrinsic to the evolving
lineage, independent of other evolving lineages (competitors, predators, etc).

This function evolves continuous characters in a discrete time process.

This function evolves continuous characters in a discrete time process.

This function retrieves branch lengths and ancestor-decendant relationships
from a tree

This function retrieves branch lengths and ancestor-decendant relationships
from a tree

This function mutates the character state of a given taxon by one discrete
time step

This is a wrapper function for simulateData that allows for multithreading
and checkpointing

This function uses the particleDataFrame from TreEvo results and plots
parent-offspring particles from generation to generation.

This function plots posterior distributions from the last generation of each
free parameter

This function plots the distribution of priors

This function pulls random values from the prior

This function pulls values from the posterior distribution
}
\details{
Returns a matrix of prior values that can be used in the doRun functions.
Builds on functions in geiger to estimate distribution.

This function performs the ABC-rejection analysis using an input simulation
data. Particles are accepted is they fall sufficiently close to the target
data (within the tolerance). Distances are calculated using \code{abcDistance}.

This function uses the scores from the pls model to transform the summary
statistics.

The following intrinsic models are:

\code{nullIntrinsic} describes a model of no intrinsic character change.

It has no parameters, really.

\code{brownianIntrinsic} describes a model of intrinsic character evolution via
Brownian motion.

The input parameters for this model are:
\code{boundaryIntrinsic} params = sd

\code{boundaryIntrinsic} describes a model of intrinsic character evolution where character
change is restricted above a minimum and below a maximum threshold.

The input parameters for this model are:
\code{boundaryMinIntrinsic} params = sd, minimum, maximum

\code{boundaryMinIntrinsic} describes a model of intrinsic character evolution where character
change is restricted above a minimum threshold.

The input parameters for this model are:
\code{boundaryMinIntrinsic} params = sd, minimum

\code{autoregressiveIntrinsic} describes a model of intrinsic character evolution. New
character values are generated after one time step via a discrete-time OU
process.

The input parameters for this model are:
\code{autoregressiveIntrinsic} params = sd (sigma), attractor (character
mean), attraction (alpha)

\code{minBoundaryAutoregressiveIntrinsic} describes a model of intrinsic character evolution. New
character values are generated after one time step via a discrete-time OU
process with a minimum bound.

The input parameters for this model are:
\code{MinBoundaryAutoregressiveIntrinsic} params = sd (sigma), attractor
(character mean), attraction (alpha), minimum

\code{autoregressiveIntrinsicTimeSlices} describes a model of intrinsic character evolution. New
character values are generated after one time step via a discrete-time OU
process with differing means, sigma, and attraction over time

In the various TimeSlices models, time threshold units are in time before present
(i.e., 65 could be 65 MYA). The last time threshold should be 0.

The input parameters for this model are:
\code{autoregressiveIntrinsicTimeSlices} params = sd-1 (sigma-1),
attractor-1 (character mean-1), attraction-1 (alpha-1), time threshold-1,
sd-2 (sigma-2), attractor-2 (character mean-2), attraction-2 (alpha-2), time
threshold-2

\code{autoregressiveIntrinsicTimeSlicesConstantMean} describes a model of intrinsic character evolution. New
character values are generated after one time step via a discrete-time OU
process with differing sigma and attraction over time

The input parameters for this model are:
\code{autoregressiveIntrinsicTimeSlicesConstantMean} params = sd-1
(sigma-1), attraction-1 (alpha-1), time threshold-1, sd-2 (sigma-2),
attraction-2 (alpha-2), time threshold-2, attractor (character mean)

\code{autoregressiveIntrinsicTimeSlicesConstantSigma} describes a model of intrinsic character evolution. New
character values are generated after one time step via a discrete-time OU
process with differing means and attraction over time.

The input parameters for this model are:
\code{autoregressiveIntrinsicTimeSlicesConstantSigma} params = sd (sigma),
attractor-1 (character mean-1), attraction-1 (alpha-1), time threshold-1,
attractor-2 (character mean-2), attraction-2 (alpha-2), time threshold-2

When saveHistory is TRUE, processor time will increase quite a bit.
SaveRealParams is useful for tracking the "real" true values if simulating
data for abc runs.  It is not useful for empirical abc runs.

When saveHistory is TRUE, processor time will increase quite a bit.
SaveRealParams is useful for tracking the "real" true values if simulating
data for abc runs.  It is not useful for empirical abc runs.

This function is used by other TreEvo functions for internal calculations.

This function is used by other TreEvo functions for internal calculations.

Each parameter is plotted twice for parent-offspring relationships through
the generations.  In the top row, particles are plotted as a measure of
distance to the observed data; the farther away the particle the bigger the
circle.  Gray circles indicate rejected particles.  In the bottom row,
particles are plotted as a measure of their weights; larger circles are
closer to observed data and therefore carry more weight in the analysis.
Grayed out stars represent rejected particles.

If the particleDataFrame is a list of seperate TreEvo runs, posteriors will
be layered over eachother to check for repeatability.  Grayscale of
posteriors depends on total number of runs.

If the PriorMatrix is a list of matrices, only the first matrix will be
plotted.  In other words, prior matrices MUST be identical for all runs.

realParam and realParamValues should only be used with simulated data, where
the true values are known.

This functions is to help visualize the shape of the priors for TreEvo abc
analyses.
}
\examples{

#GetBMRatePrior(phy, traits, timeStep)



#PLSRejection(summaryValuesMatrix, trueFreeValuesMatrix, phy, traits, abcTolerance)


#PLSTransform(summaryValuesMatrix, pls.model)

# this needs examples



phy<-rcoal(30)

#Simple Brownian motion
char<-doSimulation(
	splits=getSimulationSplits(phy),
	intrinsicFn=brownianIntrinsic,
	extrinsicFn=nullExtrinsic,
	startingValues=c(10), #root state
	intrinsicValues=c(0.01),
	extrinsicValues=c(0),
	timeStep=0.0001,
	saveHistory=FALSE)


#Character displacement model with minimum bound
char<-doSimulation(
	splits=getSimulationSplits(phy),
	intrinsicFn=boundaryMinIntrinsic,
	extrinsicFn=ExponentiallyDecayingPushExtrinsic,
	startingValues=c(10), #root state
	intrinsicValues=c(0.05, 10, 0.01),
	extrinsicValues=c(0, .1, .25),
	timeStep=0.001,
	saveHistory=FALSE)



phy<-rcoal(30)

#Simple Brownian motion
char<-doSimulation(
	splits=getSimulationSplits(phy),
	intrinsicFn=brownianIntrinsic,
	extrinsicFn=nullExtrinsic,
	startingValues=c(10), #root state
	intrinsicValues=c(0.01),
	extrinsicValues=c(0),
	timeStep=0.0001,
	saveHistory=FALSE)


#Character displacement model with minimum bound
char<-doSimulation(
	splits=getSimulationSplits(phy),
	intrinsicFn=boundaryMinIntrinsic,
	extrinsicFn=ExponentiallyDecayingPushExtrinsic,
	startingValues=c(10), #root state
	intrinsicValues=c(0.05, 10, 0.01),
	extrinsicValues=c(0, .1, .25),
	timeStep=0.001,
	saveHistory=FALSE)


data(simRun)
#parentOffspringPlots(res$particleDataFrame)


# data(Res)
# plotPosteriors(particleDataFrame=res$particleDataFrame,
#    PriorMatrix=res$priorMatrix, realParam=FALSE, realParamValues=NA)


	plotPrior(priorFn="exponential", priorVariables=c(10))
	
	plotPrior("normal", c(1,2))
	
	plotPrior("gamma", c(2, .2), plotQuants=FALSE, plotLegend=FALSE)

}
\author{
Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Brian O'Meara and Barb Banbury

Barb Banbury and Brian O'Meara

Brian O'Meara and Barb Banbury

Barb Banbury and Brian O'Meara

Barb Banbury and Brian O'Meara
}
