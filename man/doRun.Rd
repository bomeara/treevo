% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/doRun.R
\name{doRun}
\alias{doRun}
\alias{doRun_prc}
\alias{doRun_rej}
\title{Run Approximate Bayesian Computation for Phylogenetic Comparative Methods}
\usage{
doRun_prc(phy, traits, intrinsicFn, extrinsicFn, parallelSimulateWithPriors,
  startingPriorsFns, intrinsicPriorsValues, intrinsicPriorsFns,
  extrinsicPriorsValues, extrinsicPriorsFns, startingValuesGuess = c(),
  intrinsicValuesGuess = c(), extrinsicValuesGuess = c(),
  TreeYears = 10000, numParticles = 300, standardDevFactor = 0.2,
  StartSims = 300, plot = FALSE, epsilonProportion = 0.7,
  epsilonMultiplier = 0.7, nStepsPRC = 5, jobName = NA,
  stopRule = FALSE, stopValue = 0.05, multicore = FALSE, coreLimit = NA,
  validation = "CV", scale = TRUE, variance.cutoff = 95, niter.goal = 5,
  generation.time = 1)

doRun_rej(phy, traits, intrinsicFn, extrinsicFn, parallelSimulateWithPriors,
  startingPriorsFns, intrinsicPriorsValues, intrinsicPriorsFns,
  extrinsicPriorsValues, extrinsicPriorsFns, startingValuesGuess = c(),
  intrinsicValuesGuess = c(), extrinsicValuesGuess = c(),
  TreeYears = 10000, standardDevFactor = 0.2, StartSims = NA,
  jobName = NA, abcTolerance = 0.1, multicore = FALSE, coreLimit = NA,
  checkpointFile = NULL, checkpointFreq = 24, validation = "CV",
  scale = TRUE, variance.cutoff = 95, savesims = FALSE, niter.goal = 5,
  generation.time = 1)
}
\arguments{
\item{phy}{A phylogenetic tree, in package \code{ape}'s \code{phylo} format.}

\item{traits}{Data matrix with rownames identical to \code{phy@tip.label}.}

\item{intrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, regardless of the trait values of other taxa.}

\item{extrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, based on their own ('internal') trait vlaue and the trait values
of other taxa.}

\item{parallelSimulateWithPriors}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{startingPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{intrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the intrinsic function and nrow=2 (two parameters to pass to prior distribution)}

\item{intrinsicPriorsFns}{Vector containing names of prior distributions to
use for intrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{extrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the extrinsic function and nrow=2 (two parameters to pass to prior distribution)}

\item{extrinsicPriorsFns}{Vector containing names of prior distributions to
use for extrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{startingValuesGuess}{Optional guess of starting values.}

\item{intrinsicValuesGuess}{Optional guess of intrinsic values.}

\item{extrinsicValuesGuess}{Optional guess of extrinsic values.}

\item{TreeYears}{Unit length of phy}

\item{numParticles}{Number of accepted particles per generation}

\item{standardDevFactor}{Standard deviation for mutating states}

\item{StartSims}{Number of initial simulations}

\item{plot}{If TRUE, plots distance of each simulation}

\item{epsilonProportion}{Sets tolerance for initial simulations}

\item{epsilonMultiplier}{Sets tolerance on subsequent generations}

\item{nStepsPRC}{Number of generations}

\item{jobName}{Optional job name}

\item{stopRule}{If TRUE, an analysis will be terminated prior to set number
of generations if the ratio of all parameters from one generation to the
next falls below the stopValue}

\item{stopValue}{Threshold value for terminating an analysis prior to
nStpesPRC}

\item{multicore}{Whether to use multicore, default is \code{FALSE}. If \code{TRUE}, one of
two suggested packages must be installed, either \code{doMC} (for UNIX systems) or
\code{doParallel} (for Windows), which are used to activate multithreading.
If neither package is installed, this function will fail if \code{multicore=TRUE}.}

\item{coreLimit}{Maximum number of cores to be used.}

\item{validation}{Character argument controlling what validation procedure is used by \code{\link{plsr}}.
Default is \code{"CV"} for cross-validation.}

\item{scale}{This argument is passed to \code{\link{plsr}}.  It may be a numeric vector, or logical. If numeric vector, 
the input is scaled by dividing each variable with the corresponding element of scale. 
If \code{scale = TRUE}, the inpus is scaled by dividing each variable by its sample standard deviation. 
If cross-validation is selected (the default for \code{returnPLSModel}),
scaling by the standard deviation is done for every segment.}

\item{variance.cutoff}{Minimum threshold percentage of variance explained for the
number of components included in the final PLS model fit. This value is a 
percentage and must be between 0 and 100. Default is 95 percent.}

\item{niter.goal}{Adjust number of starting points for Geiger to return the best parameter estimates this number of times on average}

\item{generation.time}{The number of years per generation. This sets the coarseness of the simulation; if it's set to 1000, 
for example, the population moves every 1000 years.}

\item{abcTolerance}{Proportion of accepted simulations}

\item{checkpointFile}{Optional file name for checkpointing simulations}

\item{checkpointFreq}{Saving frequency for checkpointing}

\item{savesims}{option to save individual simulations}
}
\value{
The output of these two functions are lists, composed of multiple objects,
which differ slightly in their content among the two functions. For \code{doRun_prc}, the output is:
\describe{
\item{input.data}{Input variables: jobName, number of taxa, nrepSim,
treeYears, epsilonProportion, epsilonMultiplier, nStepsPRC, numParticles, standardDevFactor} 
\item{PriorMatrix}{Matrix of prior distributions}
\item{particleDataFrame}{DataFrame with information from each simulation,
including generation, attempt, id, parentid, distance, weight, and parameter states}
\item{toleranceVector}{Final tolerance vector} 
\item{phy}{Input phylogeny} 
\item{traits}{Input traits} \item{simTime}{Processor time for initial simulations} 
\item{time.per.gen}{Processor time for subsequent generations}
\item{whichVip}{Matrix of vip summary statistics for each free parameter} 
\item{credibleInt}{Credible Interval calculation for each free parameter of the final generation} 
\item{HPD}{Highest Posterior Density calculation each free parameter of the final generation}
}
For \code{doRun_rej}, the output is:
\describe{
\item{input.data}{Input variables: jobName, number of taxa, nrepSim,
treeYears, epsilonProportion, epsilonMultiplier, nStepsPRC, numParticles, standardDevFactor} 
\item{PriorMatrix}{Matrix of prior distributions}
\item{phy}{Input phylogeny} 
\item{traits}{Input traits}
\item{trueFreeValuesANDSummaryValues}{Parameter estimates and summary stats from all sims} 
\item{simTime}{Processor time for simulations}
\item{whichVip}{Matrix of vip summary statistics for each free parameter}
\item{abcDistancesRaw}{Euclidean distances for each simulation and free parameter} 
\item{particleDataFrame}{DataFrame with information from each 
simulation, including generation, attempt, id, parentid, distance, weight, and parameter states} 
\item{credibleInt}{Credible Interval calculation for each free parameter of the final generation} 
\item{HPD}{Highest Posterior Density calculation each free parameter of the final generation}
}
}
\description{
Partial Rejection Control
}
\details{
Rejection

Starts the ABC-rejection run.

This function performs an abc-prc analysis using an input phylogeny (phy),
character data set (traits), models (intrinsicFn, extrinsicFn), and priors
(parallelSimulateWithPriors, startingPriorsFns, intrinsicPriorsValues,
intrinsicPriorsFns, extrinsicPriorsValues, extrinsicPriorsFns). Pulling from
the priors, it simulates an initial set of simulations (StartSims). The set
of simulations are boxcox transformed and a pls regression is performed for
each free parameter to determine the most informative summary statistics
(vipthresh). The euclidean distance of each initial simulation's vip summary
stats to the input data is calculated, and tolerance is set based on
epsilonProportion and epsilonMultiplier.

The prc analysis begins with generation 1 and continues through nStepsPRC.
Single simulations (or particles) are accepted if the distance of vip
summary stats to the original data is less than the tolerance. A generation
is complete when enough particles (numParticles) have been accepted. These
particles make up the distribution for the next generation. The accepted
particles from the final generation describe the posterior distributions of
parameters.

This function performs an abc-rejection analysis using an input phylogeny
(phy), character data set (traits), models (intrinsicFn, extrinsicFn), and
priors (parallelSimulateWithPriors, startingPriorsFns, intrinsicPriorsValues,
intrinsicPriorsFns, extrinsicPriorsValues, extrinsicPriorsFns). Pulling from
the priors, it performs StartSims simulations. This set of simulations are
boxcox transformed and a pls regression is performed for each free parameter
to determine the most informative summary statistics (vipthresh). The
euclidean distance of each initial simulation's vip summary stats to the
input data is calculated, and those that fall under the abcTolerance are
kept as accepted particles. These describe the posterior distributions of
parameters.
}
\examples{

data(simRun)

doRun_prc(
  phy = simPhy,
  traits = simChar,
  intrinsicFn=brownianIntrinsic,
  extrinsicFn=nullExtrinsic,
  startingPriorsFns="normal",
  parallelSimulateWithPriors=matrix(c(mean(simChar[,1]), sd(simChar[,1]))),
  intrinsicPriorsFns=c("exponential"),
  intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE),
  extrinsicPriorsFns=c("fixed"),
  extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE),
  TreeYears=1000,
  standardDevFactor=0.2,
  plot=FALSE,
  StartSims=300,
  epsilonProportion=0.7,
  epsilonMultiplier=0.7,
  nStepsPRC=5,
  numParticles=100,
  jobName="exampleRun",
  stopRule=FALSE,
  multicore=FALSE,
  coreLimit=1
)


#make sure priors are uniform with this one!
result<-doRun_rej( 
	phy=simPhy,
	traits=simChar,
	intrinsicFn=brownianIntrinsic,
	extrinsicFn=nullExtrinsic,
	startingPriorsFns="normal",
	parallelSimulateWithPriors=matrix(c(mean(char[,1]), sd(char[,1]))),
	intrinsicPriorsFns=c("exponential"),
	intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE), #grep for normal in pkg
	extrinsicPriorsFns=c("fixed"),
	extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE),
	StartSims=1000,
	jobName="run_c",
	abcTolerance=0.05,
	multicore=F,
	coreLimit=1
	)



}
\references{
Sisson et al. 2007, Wegmann et
al. 2009
}
\author{
Brian O'Meara and Barb Banbury
}
