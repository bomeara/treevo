% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/doRun.R
\name{doRun}
\alias{doRun}
\alias{doRun_prc}
\alias{doRun_rej}
\title{Run Approximate Bayesian Computation for Phylogenetic Comparative Methods}
\usage{
doRun_prc(phy, traits, intrinsicFn, extrinsicFn, startingPriorsValues,
  startingPriorsFns, intrinsicPriorsValues, intrinsicPriorsFns,
  extrinsicPriorsValues, extrinsicPriorsFns, startingValuesGuess = c(),
  intrinsicValuesGuess = c(), extrinsicValuesGuess = c(),
  TreeYears = 10000, multicore = FALSE, coreLimit = NA,
  validation = "CV", scale = TRUE, variance.cutoff = 95, niter.goal = 5,
  generation.time = 1, numParticles = 300, standardDevFactor = 0.2,
  StartSims = 300, epsilonProportion = 0.7, epsilonMultiplier = 0.7,
  nStepsPRC = 5, jobName = NA, stopRule = FALSE, stopValue = 0.05,
  plot = FALSE)

doRun_rej(phy, traits, intrinsicFn, extrinsicFn, startingPriorsValues,
  startingPriorsFns, intrinsicPriorsValues, intrinsicPriorsFns,
  extrinsicPriorsValues, extrinsicPriorsFns, startingValuesGuess = c(),
  intrinsicValuesGuess = c(), extrinsicValuesGuess = c(),
  TreeYears = 10000, multicore = FALSE, coreLimit = NA,
  validation = "CV", scale = TRUE, variance.cutoff = 95, niter.goal = 5,
  generation.time = 1, standardDevFactor = 0.2, StartSims = NA,
  jobName = NA, abcTolerance = 0.1, checkpointFile = NULL,
  checkpointFreq = 24, savesims = FALSE)
}
\arguments{
\item{phy}{A phylogenetic tree, in package \code{ape}'s \code{phylo} format.}

\item{traits}{Data matrix with rownames identical to \code{phy@tip.label}.}

\item{intrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, regardless of the trait values of other taxa.}

\item{extrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, based on their own ('internal') trait vlaue and the trait values
of other taxa.}

\item{startingPriorsValues}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{startingPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{intrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the intrinsic function and nrow=2 (two parameters to pass to prior distribution)}

\item{intrinsicPriorsFns}{Vector containing names of prior distributions to
use for intrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{extrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the extrinsic function and nrow=2 (two parameters to pass to prior distribution)}

\item{extrinsicPriorsFns}{Vector containing names of prior distributions to
use for extrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{startingValuesGuess}{Optional guess of starting values.}

\item{intrinsicValuesGuess}{Optional guess of intrinsic values.}

\item{extrinsicValuesGuess}{Optional guess of extrinsic values.}

\item{TreeYears}{Absolute scale of time-units for \code{phy}, from the root
to the furthest tip (sometimes referred to as 'unit-length'). For ultrametric
trees where all tips are at time zero (i.e., the modern day), this would be
the root age of the tree. By default, this is set to 10000 time-units.}

\item{multicore}{Whether to use multicore, default is \code{FALSE}. If \code{TRUE}, one of
two suggested packages must be installed, either \code{doMC} (for UNIX systems) or
\code{doParallel} (for Windows), which are used to activate multithreading.
If neither package is installed, this function will fail if \code{multicore=TRUE}.}

\item{coreLimit}{Maximum number of cores to be used.}

\item{validation}{Character argument controlling what validation procedure is used by \code{\link{plsr}}.
Default is \code{"CV"} for cross-validation.}

\item{scale}{This argument is passed to \code{\link{plsr}}.  It may be a numeric vector, or logical. If numeric vector, 
the input is scaled by dividing each variable with the corresponding element of scale. 
If \code{scale = TRUE}, the inpus is scaled by dividing each variable by its sample standard deviation. 
If cross-validation is selected (the default for \code{returnPLSModel}),
scaling by the standard deviation is done for every segment.}

\item{variance.cutoff}{Minimum threshold percentage of variance explained for the
number of components included in the final PLS model fit. This value is a 
percentage and must be between 0 and 100. Default is 95 percent.}

\item{niter.goal}{Adjust number of starting points for package \code{geiger} to return the best parameter estimates this number of times on average.}

\item{generation.time}{The number of years per generation. This sets the coarseness of the simulation; if it's set to 1000, 
for example, the population moves every 1000 years.}

\item{numParticles}{Number of accepted particles per generation.}

\item{standardDevFactor}{Standard deviation for mutating states.}

\item{StartSims}{Number of initial simulations.}

\item{epsilonProportion}{Sets tolerance for initial simulations.}

\item{epsilonMultiplier}{Sets tolerance on subsequent generations.}

\item{nStepsPRC}{Number of generations to run.}

\item{jobName}{Optional job name.}

\item{stopRule}{If \code{TRUE}, an analysis will be terminated prior to set number
of generations if the ratio of all parameters from one generation to the
next falls below the \code{stopValue}.}

\item{stopValue}{Threshold value for terminating an analysis prior to
\code{nStepesPRC}.}

\item{plot}{If \code{TRUE}, plots distance of each simulation.}

\item{abcTolerance}{Proportion of accepted simulations.}

\item{checkpointFile}{Optional file name for checkpointing simulations.}

\item{checkpointFreq}{Saving frequency for checkpointing.}

\item{savesims}{Option to save individual simulations.}
}
\value{
The output of these two functions are lists, composed of multiple objects,
which differ slightly in their content among the two functions. For \code{doRun_prc}, the output is:
\describe{
\item{input.data}{Input variables: jobName, number of taxa, nrepSim,
treeYears, epsilonProportion, epsilonMultiplier, nStepsPRC, numParticles, standardDevFactor} 
\item{PriorMatrix}{Matrix of prior distributions}
\item{particleDataFrame}{DataFrame with information from each simulation,
including generation, attempt, id, parentid, distance, weight, and parameter states}
\item{toleranceVector}{Final tolerance vector} 
\item{phy}{Input phylogeny} 
\item{traits}{Input traits} \item{simTime}{Processor time for initial simulations} 
\item{time.per.gen}{Processor time for subsequent generations}
\item{credibleInt}{Credible Interval calculation for each free parameter of the final generation} 
\item{HPD}{Highest Posterior Density calculation each free parameter of the final generation}
}
For \code{doRun_rej}, the output is:
\describe{
\item{input.data}{Input variables: jobName, number of taxa, nrepSim,
treeYears, epsilonProportion, epsilonMultiplier, nStepsPRC, numParticles, standardDevFactor} 
\item{PriorMatrix}{Matrix of prior distributions}
\item{phy}{Input phylogeny} 
\item{traits}{Input traits}
\item{trueFreeValuesANDSummaryValues}{Parameter estimates and summary stats from all sims} 
\item{simTime}{Processor time for simulations}
\item{abcDistancesRaw}{Euclidean distances for each simulation and free parameter} 
\item{particleDataFrame}{DataFrame with information from each 
simulation, including generation, attempt, id, parentid, distance, weight, and parameter states} 
\item{credibleInt}{Credible Interval calculation for each free parameter of the final generation} 
\item{HPD}{Highest Posterior Density calculation each free parameter of the final generation}
}
}
\description{
The \code{doRun} functions are the main interface for \code{TreEvo} users to do Approximate Bayesian Computation (ABC) analysis,
effectively wrapping the \code{\link{simulateWithPriors}} functions to perform simulations, which
themselves are wrappers for the the \code{\link{doSimulation}} functions. The two current \code{doRun}
functions are \code{doRun_prc} which applies a partial rejection control(PRC) ABC analysis over multiple generations of simulations,
and \code{doRun_rej} which performs a full rejection ('rej') ABC analysis.
}
\details{
Both \code{doRun} functions take an input phylogeny (\code{phy}),
observed trait data set (\code{traits}), models (\code{intrinsicFn}, \code{extrinsicFn}), and priors
(\code{startingPriorsValues}, \code{startingPriorsFns}, \code{intrinsicPriorsValues},
\code{intrinsicPriorsFns}, \code{extrinsicPriorsValues}, \code{extrinsicPriorsFns}). Pulling from
the priors, it simulates an initial set of simulations (\code{StartSims}). This set of simulations is
boxcox transformed ,and a PLS regression (see \code{\link{PLSmethods}}) is performed for each free parameter
to determine the most informative summary statistics (using \code{variance.cutoff}). The euclidean distance is calculated
between each each initial simulation's most informative summary statistics and the input observed data.

Following that step, the approach of the two functions diverge drastically.

For function \code{doRun_rej}, those simulations whose most informative summary statistics fall below
\code{abcTolerance} are kept as accepted 'particles' (simulations runs), describing the
posterior distribution of parameters. No additional generations of simulations are performed.

Coversely, function \code{doRun_prc} performs an ABC-PRC analysis,
which follows a much more complicated algorithm with additional generations. In PRC, tolerance is set based on
\code{epsilonProportion} and \code{epsilonMultiplier}, and the analysis
begins with generation 1 and continues through a number of generations equal to \code{nStepsPRC}.
Single simulation runs ('particles') are accepted if the distance of the
most informative summary stats to the original data is less than this tolerance. A generation
is complete when enough particles (\code{numParticles}) have been accepted. These
particles make up the distribution for the next generation. The accepted
particles from the final generation describe the posterior distributions of
parameters.
}
\examples{

\donttest{

data(simRun)

# NOTE: the example analyses below sample too few particles, 
	# over too few steps, with too few starting simulations
	# - all for the sake of examples that reasonably test the functions

# Please set these values to more realistic levels for your analyses!

doRun_prc(
  phy = simPhy,
  traits = simChar,
  intrinsicFn=brownianIntrinsic,
  extrinsicFn=nullExtrinsic,
  startingPriorsFns="normal",
  startingPriorsValues=matrix(c(mean(simChar[,1]), sd(simChar[,1]))),
  intrinsicPriorsFns=c("exponential"),
  intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE),
  extrinsicPriorsFns=c("fixed"),
  extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE),
  TreeYears=1000,
  standardDevFactor=0.2,
  plot=FALSE,
  StartSims=10,
  epsilonProportion=0.7,
  epsilonMultiplier=0.7,
  nStepsPRC=3,
  numParticles=20,
  jobName="examplerun_prc",
  stopRule=FALSE,
  multicore=FALSE,
  coreLimit=1
)


#make sure priors are uniform with doRun_rej

doRun_rej( 
	phy=simPhy,
	traits=simChar,
	intrinsicFn=brownianIntrinsic,
	extrinsicFn=nullExtrinsic,
	startingPriorsFns="normal",
	startingPriorsValues=matrix(c(mean(char[,1]), sd(char[,1]))),
	intrinsicPriorsFns=c("exponential"),
	intrinsicPriorsValues=matrix(c(10, 10), nrow=2, byrow=FALSE), #grep for normal in pkg
	extrinsicPriorsFns=c("fixed"),
	extrinsicPriorsValues=matrix(c(0, 0), nrow=2, byrow=FALSE),
	StartSims=10,
	jobName="examplerun_rej",
	abcTolerance=0.05,
	multicore=F,
	coreLimit=1
	)

}

}
\references{
Sisson et al. 2007, Wegmann et
al. 2009
}
\author{
Brian O'Meara and Barb Banbury
}
