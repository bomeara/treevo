% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/doRun.R, R/doRun_rej.R
\name{doRun}
\alias{doRun}
\alias{doRun_prc}
\alias{doRun_rej}
\title{Run Approximate Bayesian Computation for Phylogenetic Comparative Methods}
\usage{
doRun_prc(phy, traits, intrinsicFn, extrinsicFn, startingPriorsValues,
  startingPriorsFns, intrinsicPriorsValues, intrinsicPriorsFns,
  extrinsicPriorsValues, extrinsicPriorsFns, numParticles = 300,
  nStepsPRC = 5, nRuns = 2, nInitialSims = NULL,
  nInitialSimsPerParam = 100, generation.time = 1000,
  TreeYears = max(branching.times(phy)) * 1e+06, multicore = FALSE,
  coreLimit = NA, multicoreSuppress = FALSE, standardDevFactor = 0.2,
  epsilonProportion = 0.7, epsilonMultiplier = 0.7, validation = "CV",
  scale = TRUE, variance.cutoff = 95, stopRule = FALSE,
  stopValue = 0.05, maxAttempts = Inf, diagnosticPRCmode = FALSE,
  jobName = NA, saveData = FALSE, verboseParticles = TRUE)

doRun_rej(phy, traits, intrinsicFn, extrinsicFn, startingPriorsValues,
  startingPriorsFns, intrinsicPriorsValues, intrinsicPriorsFns,
  extrinsicPriorsValues, extrinsicPriorsFns, generation.time = 1000,
  TreeYears = max(branching.times(phy)) * 1e+06, multicore = FALSE,
  coreLimit = NA, validation = "CV", scale = TRUE, nInitialSims = NULL,
  nInitialSimsPerParam = 100, variance.cutoff = 95,
  standardDevFactor = 0.2, jobName = NA, abcTolerance = 0.1,
  checkpointFile = NULL, checkpointFreq = 24, savesims = FALSE)
}
\arguments{
\item{phy}{A phylogenetic tree, in package \code{ape}'s \code{phylo} format.}

\item{traits}{Data matrix with rownames identical to \code{phy@tip.label}. 
If a vector, \code{traits} will be coerced to a matrix, with element names as rownames.}

\item{intrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, regardless of the trait values of other taxa.}

\item{extrinsicFn}{Name of (previously-defined) function that governs how
traits evolve within a lineage, based on their own ('internal') trait vlaue and the trait values
of other taxa.}

\item{startingPriorsValues}{Matrix with number of columns equal to the number of states (characters)
at root and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{startingPriorsFns}{Vector containing names of prior distributions to
use for root states: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{intrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the intrinsic function and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{intrinsicPriorsFns}{Vector containing names of prior distributions to
use for intrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{extrinsicPriorsValues}{Matrix with number of columns equal to the number of parameters to pass
to the extrinsic function and number of rows equal to two (representing two parameters to pass to prior distribution).}

\item{extrinsicPriorsFns}{Vector containing names of prior distributions to
use for extrinsic function parameters: can be one of \code{"fixed"}, \code{"uniform"}, \code{"normal"},}

\item{numParticles}{Number of accepted particles per PRC generation.}

\item{nStepsPRC}{Number of PRC generations to run.}

\item{nRuns}{Number of independent PRC runs to be performed, each consisting of independent sets of
initial simulations and PRC generations. Note that runs are run \emph{sequentially}, and not in parallel, 
as the generation of particles within each run makes use of the multicore functionality.
If \code{nRuns} is greater than 1, the output from \code{doRun_prc} will be a list object composed of
multiple output lists, as described.}

\item{nInitialSims}{Number of initial simulations used to calibrate particle rejection control algorithm.
If not given, this will be a function of the number of freely varying parameters.}

\item{nInitialSimsPerParam}{If \code{nInitialSims} is not given by the user, the number of initial simulations
performed to calibrate the particle rejection algorithm will instead be the number of free parameters
in the model multiplied by \code{nInitialSimsPerParam}.}

\item{generation.time}{The number of years per generation. This sets the coarseness of the simulation; if it's set to 1000, 
for example, the population's trait values change every 1000 calender years. Note that this is in calender years (see description
for argument \code{TreeYears}), and not in millions of years (as is typical for dated trees in macroevolutionary studies).
Thus, if a branch is 1 million-year time-unit long, and a user applies the default \code{generation.time = 1000}, 
then 1000 evolutionary changes will be simulated along that branch.
See documentation for \code{\link{doSimulation}} for further details.}

\item{TreeYears}{The amount of calender time from the root to the furthest tip. Most trees in macroevolutionary studies are dated with
branch lengths in units of millions of years, and thus the default for this argument is \code{max(branching.times(phy)) * 1e6}.
If your tree has the most recent tip at time zero (i.e., the modern day), this would be the same as the root age of the tree. If your
branch lengths are not in millions of years, you should alter this argument. Otherwise, leave this argument alone.
See documentation for \code{\link{doSimulation}} for further details.}

\item{multicore}{Whether to use multicore, default is \code{FALSE}. If \code{TRUE}, one of
two suggested packages must be installed, either \code{doMC} (for UNIX systems) or
\code{doParallel} (for Windows), which are used to activate multithreading.
If neither package is installed, this function will fail if \code{multicore = TRUE}.}

\item{coreLimit}{Maximum number of cores to be used.}

\item{multicoreSuppress}{Argument to suppress multicore code and use a plain vanilla \code{fore()} loop instead
of \code{doPar}. Mainly to be used for developer diagnostic purposes.}

\item{standardDevFactor}{Standard deviation for mutating states each time a new particle is generated in a PRC generation.}

\item{epsilonProportion}{Sets tolerance for initial simulations.}

\item{epsilonMultiplier}{Sets tolerance on subsequent PRC generations.}

\item{validation}{Character argument controlling what validation procedure is used by \code{\link{plsr}}.
Default is \code{"CV"} for cross-validation.}

\item{scale}{This argument is passed to \code{\link{plsr}}.  It may be a numeric vector, or logical. If numeric vector, 
the input is scaled by dividing each variable with the corresponding element of scale.
If \code{scale = TRUE}, the inpus is scaled by dividing each variable by its sample standard deviation.
If cross-validation is selected (the default for \code{returnPLSModel}), 
scaling by the standard deviation is done for every segment.}

\item{variance.cutoff}{Minimum threshold percentage of variance explained for the
number of components included in the final PLS model fit. This value is a
percentage and must be between 0 and 100. Default is 95 percent.}

\item{stopRule}{If \code{TRUE}, an analysis will be terminated prior to set number
of generations if the ratio of all parameters from one generation to the
next falls below the \code{stopValue}.}

\item{stopValue}{Threshold value for terminating an analysis prior to
\code{nStepesPRC}.}

\item{maxAttempts}{Maximum number attempts made in \code{while} loop within the PRC algorithm.
If reached, the algorithm will terminate with an error message.
By default, this is infinite, and thus there is no effective limit without user intervention.}

\item{diagnosticPRCmode}{If \code{TRUE} (\emph{not} the default), the function will be very noisy about characteristics of
the PRC algorithm as it runs.}

\item{jobName}{Optional job name.}

\item{saveData}{Option to save various run information during the analysis, 
including summary statistics from analyses, output to external .Rdata and .txt files.}

\item{verboseParticles}{If \code{TRUE} (the default), a large amount of information about parameter estimates
and acceptance of particles is output to console via \code{message} as \code{doRun_prc} runs.}

\item{abcTolerance}{Proportion of accepted simulations.}

\item{checkpointFile}{Optional file name for checkpointing simulations.}

\item{checkpointFreq}{Saving frequency for checkpointing.}

\item{savesims}{Option to save individual simulations, output to a .Rdata file.}
}
\value{
The output of these two functions are lists, composed of multiple objects, 
which differ slightly in their content among the two functions. For \code{doRun_prc}, the output is:
\describe{
\item{input.data}{Input variables: jobName, number of taxa, nInitialSims, 
generation.time, TreeYears, timeStep, totalGenerations, epsilonProportion, 
epsilonMultiplier, nRuns, nStepsPRC, numParticles, standardDevFactor}
\item{PriorMatrix}{Matrix of prior distributions. This is used for doing post-analysis comparisons between prior and posterior distributions, such as with function \code{plotPosteriors}}
\item{particleDataFrame}{DataFrame with information from each simulation, 
including generation, attempt, id, parentid, distance, weight, and parameter states}
\item{toleranceVector}{Final tolerance vector}
\item{phy}{Input phylogeny}
\item{traits}{Input traits} \item{simTime}{Processor time for initial simulations}
\item{time.per.gen}{Processor time for subsequent generations}
\item{postSummary}{Summarizes the posterior distribution from the final generation for all free parameters, giving the mean, standard deviation and Highest Posterior Density (at a 0.8 alpha) for each parameter.}
}

If \code{nRuns} is greater than 1, the output from \code{doRun_prc} will be a list object composed of multiple output lists, as described.

For \code{doRun_rej}, the output is:
\describe{
\item{input.data}{Input variables: jobName, number of taxa, nInitialSims, 
generation.time, TreeYears, timeStep, totalGenerations, epsilonProportion, 
epsilonMultiplier, nStepsPRC, numParticles, standardDevFactor}
\item{PriorMatrix}{Matrix of prior distributions. This is used for doing post-analysis comparisons between prior and posterior distributions, such as with function \code{plotPosteriors}}
\item{phy}{Input phylogeny}
\item{traits}{Input traits}
\item{trueFreeValuesANDSummaryValues}{Parameter estimates and summary stats from all sims}
\item{simTime}{Processor time for simulations}
\item{abcDistancesRaw}{Euclidean distances for each simulation and free parameter}
\item{particleDataFrame}{DataFrame with information from each
simulation, including generation, attempt, id, parentid, distance, weight, and parameter states}
\item{postSummary}{Summarizes the posterior distribution from the final generation for all free parameters, giving the mean, standard deviation and Highest Posterior Density (at a 0.8 alpha) for each parameter.}
}
}
\description{
The \code{doRun} functions are the main interface for \code{TreEvo} users to do Approximate Bayesian Computation (ABC) analysis, 
effectively wrapping the \code{\link{simulateWithPriors}} functions to perform simulations, which
themselves are wrappers for the \code{\link{doSimulation}} function. The two current \code{doRun}
functions are \code{doRun_prc} which applies a partial rejection control(PRC) ABC analysis over multiple generations of simulations, 
and \code{doRun_rej} which performs a full rejection ('rej') ABC analysis.
}
\details{
Both \code{doRun} functions take an input phylogeny (\code{phy}), 
observed trait data set (\code{traits}), models (\code{intrinsicFn}, \code{extrinsicFn}), and priors
(\code{startingPriorsValues}, \code{startingPriorsFns}, \code{intrinsicPriorsValues}, 
\code{intrinsicPriorsFns}, \code{extrinsicPriorsValues}, \code{extrinsicPriorsFns}). Pulling from
the priors, it simulates an initial set of simulations (\code{nInitialSims}). This set of simulations is
boxcox transformed , and a PLS regression (see \code{\link{methodsPLS}}) is performed for each free parameter
to determine the most informative summary statistics (using \code{variance.cutoff}). The euclidean distance is calculated
between each each initial simulation's most informative summary statistics and the input observed data.

Following that step, the approach of the two functions diverge drastically.

For function \code{doRun_rej}, those simulations whose most informative summary statistics fall below
\code{abcTolerance} are kept as accepted 'particles' (simulations runs), describing the
posterior distribution of parameters. No additional generations of simulations are performed.

Coversely, function \code{doRun_prc} performs an ABC-PRC analysis, 
which follows a much more complicated algorithm with additional generations. In PRC, tolerance is set based on
\code{epsilonProportion} and \code{epsilonMultiplier}, and the analysis
begins with generation 1 and continues through a number of generations equal to \code{nStepsPRC}.
Single simulation runs ('particles') are accepted if the distance of the
most informative summary stats to the original data is less than this tolerance. A generation
is complete when enough particles (\code{numParticles}) have been accepted. These
particles make up the distribution for the next generation. The accepted
particles from the final generation describe the posterior distributions of
parameters.
}
\examples{

\donttest{
set.seed(1)
data(simRunExample)

# NOTE: the example analyses below sample too few particles, 
	# over too few steps, with too few starting simulations
	# - all for the sake of examples that reasonably test the functions

# Please set these values to more realistic levels for your analyses!

resultsPRC <- doRun_prc(
  phy = simPhy, 
  traits = simChar, 
  intrinsicFn = brownianIntrinsic, 
  extrinsicFn = nullExtrinsic, 
  startingPriorsFns = "normal", 
  startingPriorsValues = matrix(c(mean(simChar[, 1]), sd(simChar[, 1]))), 
  intrinsicPriorsFns = c("exponential"), 
  intrinsicPriorsValues = matrix(c(10, 10), nrow = 2, byrow = FALSE), 
  extrinsicPriorsFns = c("fixed"), 
  extrinsicPriorsValues = matrix(c(0, 0), nrow = 2, byrow = FALSE), 
  generation.time = 10000, 
  nRuns = 2, 
  nStepsPRC = 3, 
  numParticles = 20, 
  nInitialSimsPerParam = 10, 
  jobName = "examplerun_prc", 
  stopRule = FALSE, 
  multicore = FALSE, 
  coreLimit = 1
)

resultsPRC

#one should make sure priors are uniform with doRun_rej!

resultsRej <- doRun_rej(
	phy = simPhy, 
	traits = simChar, 
	intrinsicFn = brownianIntrinsic, 
	extrinsicFn = nullExtrinsic, 
	startingPriorsFns = "normal", 
	startingPriorsValues = matrix(c(mean(simChar[, 1]), sd(simChar[, 1]))), 
	intrinsicPriorsFns = c("exponential"), 
	intrinsicPriorsValues = matrix(c(10, 10), nrow = 2, byrow = FALSE), #grep for normal in pkg
	extrinsicPriorsFns = c("fixed"), 
	extrinsicPriorsValues = matrix(c(0, 0), nrow = 2, byrow = FALSE), 
generation.time = 10000, 
	jobName = "examplerun_rej", 
	abcTolerance = 0.05, 
	multicore = FALSE, 
	coreLimit = 1
	)

resultsRej
}

}
\references{
Sisson et al. 2007, Wegmann et
al. 2009
}
\author{
Brian O'Meara and Barb Banbury
}
